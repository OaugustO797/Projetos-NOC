<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NOC Formatter</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js" integrity="sha512-5fQZ4MJqQms1UEWhIaU9HS7UQGnd1ohIpJUd0YbX2rY8CibW47CVxItXx1+8QV+3z1l8pKMiI8hI+q0HRN6Ehw==" crossorigin="anonymous" referrerpolicy="no-referrer" onerror="window.__xlsxFailed = true"></script>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0b1120;
      --surface: #1f2937;
      --border: #334155;
      --text: #e2e8f0;
      --text-muted: #94a3b8;
      --accent: #38bdf8;
      --accent-hover: #0ea5e9;
      --danger: #f97316;
      font-size: 16px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.9), var(--bg));
      color: var(--text);
      font-family: "Segoe UI", "Helvetica Neue", Roboto, sans-serif;
      line-height: 1.5;
      min-height: 100vh;
    }

    h1 {
      font-size: clamp(1.5rem, 2vw + 1rem, 2.5rem);
      margin-bottom: 0.25rem;
      text-align: center;
      letter-spacing: 0.04em;
    }

    .subtitle {
      text-align: center;
      color: var(--text-muted);
      margin-bottom: 2rem;
    }

    .wrapper {
      max-width: 1080px;
      margin: 0 auto;
      padding: 2.5rem 1.5rem 3rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    label {
      display: block;
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: var(--text);
    }

    input[type="text"] {
      width: 100%;
      padding: 0.85rem 1rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      background: rgba(30, 41, 59, 0.6);
      color: var(--text);
      font-size: 0.95rem;
      box-shadow: inset 0 0 0 999px rgba(8, 47, 73, 0.06);
    }

    input[type="text"]:focus {
      outline: 2px solid var(--accent);
      outline-offset: 0;
    }

    textarea {
      width: 100%;
      min-height: 220px;
      padding: 1rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      background: rgba(30, 41, 59, 0.6);
      color: var(--text);
      resize: vertical;
      font-family: "Fira Code", "JetBrains Mono", "Consolas", monospace;
      font-size: 0.95rem;
      line-height: 1.6;
      box-shadow: inset 0 0 0 999px rgba(8, 47, 73, 0.1);
    }

    textarea:focus {
      outline: 2px solid var(--accent);
      outline-offset: 0;
    }

    pre {
      width: 100%;
      min-height: 220px;
      padding: 1rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.75);
      color: var(--text);
      font-family: "Fira Code", "JetBrains Mono", "Consolas", monospace;
      font-size: 0.95rem;
      line-height: 1.6;
      white-space: pre-wrap;
      word-break: break-word;
      margin: 0;
    }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      justify-content: center;
    }

    button {
      appearance: none;
      border: none;
      border-radius: 999px;
      padding: 0.75rem 1.75rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      cursor: pointer;
      color: var(--text);
      background: linear-gradient(135deg, rgba(56, 189, 248, 0.85), rgba(14, 165, 233, 0.95));
      box-shadow: 0 10px 25px rgba(8, 145, 178, 0.35);
      transition: transform 0.15s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 14px 30px rgba(14, 165, 233, 0.4);
      background: linear-gradient(135deg, var(--accent-hover), rgba(56, 189, 248, 0.95));
    }

    button:active {
      transform: translateY(1px);
    }

    button.secondary {
      background: linear-gradient(135deg, rgba(129, 140, 248, 0.75), rgba(59, 130, 246, 0.85));
      box-shadow: 0 10px 25px rgba(59, 130, 246, 0.35);
    }

    button.ghost {
      background: linear-gradient(135deg, rgba(100, 116, 139, 0.7), rgba(71, 85, 105, 0.8));
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.35);
    }

    button.danger {
      background: linear-gradient(135deg, rgba(251, 146, 60, 0.85), rgba(249, 115, 22, 0.9));
      box-shadow: 0 10px 24px rgba(249, 115, 22, 0.35);
    }

    .panel {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .rules-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 0.75rem;
    }

    .rules-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .rules-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      padding: 0.75rem;
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      background: rgba(15, 23, 42, 0.5);
    }

    .rule-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      background: rgba(148, 163, 184, 0.08);
    }

    .rule-texts {
      display: flex;
      flex-direction: column;
      gap: 0.125rem;
      flex: 1;
      min-width: 0;
    }

    .rule-texts strong {
      color: var(--accent);
    }

    .rule-texts span {
      color: var(--text-muted);
      font-size: 0.9rem;
      word-break: break-word;
    }

    .rule-buttons {
      display: flex;
      gap: 0.35rem;
    }

    .small-button {
      padding: 0.45rem 0.9rem;
      border-radius: 0.6rem;
      font-size: 0.9rem;
    }

    @media (max-width: 720px) {
      .wrapper {
        padding: 2rem 1rem 2.5rem;
      }

      textarea,
      pre {
        min-height: 180px;
      }
    }
  </style>
</head>
<body>
  <main class="wrapper">
    <header>
      <h1>NOC Formatter</h1>
      <p class="subtitle">Formate o relatório diário com poucos cliques, totalmente offline.</p>
    </header>

    <section class="panel">
      <label for="in">Entrada bruta</label>
      <textarea id="in" placeholder="Cole aqui os registros brutos do plantão..."></textarea>
    </section>

    <div class="actions">
      <button type="button" onclick="formatar()">Formatar</button>
      <button type="button" class="secondary" onclick="copiar()">Copiar Lista</button>
      <button type="button" class="ghost" onclick="limpar()">Limpar Lista</button>
      <button type="button" class="danger" onclick="exportarXLSX()">Exportar em XLSX</button>
    </div>

    <section class="panel">
      <label>Regras personalizadas</label>
      <div class="rules-grid">
        <div>
          <label for="ruleMatch">Texto a detectar</label>
          <input id="ruleMatch" type="text" placeholder="Ex.: Necessário atuação" />
        </div>
        <div>
          <label for="ruleValue">Substituição</label>
          <input id="ruleValue" type="text" placeholder="Ex.: SIM" />
        </div>
      </div>
      <div class="rules-actions">
        <button type="button" class="secondary" onclick="salvarRegra()" id="ruleSaveButton">Salvar regra</button>
        <button type="button" class="ghost" onclick="cancelarEdicao()">Cancelar edição</button>
      </div>
      <div id="rulesList" class="rules-list"></div>
    </section>

    <section class="panel">
      <label for="out">Saída formatada</label>
      <pre id="out"></pre>
    </section>
  </main>

  <script>
    const dateRegex = /^\d{1,2}\/\d{1,2}\/\d{4}$/;
    const eventRegex = /^(\d{1,2}[:h]\d{2}h?)\s*(?:-|–)\s*([A-Za-z\d-]{4,})\s*(?:-|–)\s*([A-Za-z]{3}(?:\s*,\s*[A-Za-z]{3})*)\s*(?:-|–)\s*(.+)$/;
    const STORAGE_KEY = 'nocFormatterRules';
    const defaultRules = [
      { match: 'Sem atuacao', value: 'NÃO' },
      { match: 'Servico em execucao', value: 'NÃO' },
      { match: 'Necessario execucao do servico', value: 'SIM' },
      { match: 'Necessario atuacao', value: 'SIM' },
      { match: 'Necessario a execucao', value: 'SIM' },
      { match: 'Necessario a execucao do servico', value: 'SIM' }
    ];
    const fixtures = [
      {
        description: 'Linha sem espaços entre hífens deve ser normalizada',
        input: '02:46- SEGODSCT-EMG- Necessário atuação',
        expected: '02:46 - SEGODSCT - EMG - SIM'
      }
    ];
    let formattedRows = [];
    let userRules = [];
    let editingIndex = null;

    document.addEventListener('DOMContentLoaded', () => {
      carregarRegras();
      renderizarRegras();
      validarFixtures();
    });

    function formatar() {
      const input = document.getElementById('in').value.split(/\r?\n/);
      const output = [];
      let currentDate = '';
      let lastTimeMinutes = null;
      let lastHour = null;
      formattedRows = [];

      for (const rawLine of input) {
        const line = rawLine.trim();
        if (!line) {
          continue;
        }

        if (dateRegex.test(line)) {
          currentDate = line;
          lastTimeMinutes = null;
          lastHour = null;
          output.push(line);
          continue;
        }

        const match = line.match(eventRegex);
        if (match) {
          const [, rawTime, rawService, rawCompanies, rawStatus] = match;
          const time = normalizeTime(rawTime);
          const [hour, minutes] = time.split(':').map(Number);
          const currentMinutes = hour * 60 + minutes;

          if (currentDate && lastTimeMinutes !== null) {
            if (currentMinutes < lastTimeMinutes && lastHour !== null && lastHour >= 18 && hour <= 6) {
              currentDate = incDate(currentDate);
              output.push(currentDate);
              lastTimeMinutes = null;
              lastHour = null;
            }
          }

          const service = rawService.trim().toUpperCase();
          const companies = rawCompanies
            .trim()
            .split(/\s*,\s*/)
            .map((c) => c.trim().toUpperCase())
            .filter(Boolean);
          const status = normalizeStatus(rawStatus.trim());

          for (const company of companies) {
            output.push(`${time} - ${service} - ${company} - ${status}`);
            if (currentDate) {
              formattedRows.push({ date: currentDate, time, service, company, status });
            }
          }

          lastTimeMinutes = currentMinutes;
          lastHour = hour;
          continue;
        }

        output.push(line);
      }

      document.getElementById('out').textContent = output.join('\n');
    }

    function formatarLinhaParaTeste(line) {
      const trimmedLine = line.trim();
      const match = trimmedLine.match(eventRegex);
      if (!match) {
        return [trimmedLine];
      }

      const [, rawTime, rawService, rawCompanies, rawStatus] = match;
      const time = normalizeTime(rawTime);
      const service = rawService.trim().toUpperCase();
      const companies = rawCompanies
        .trim()
        .split(/\s*,\s*/)
        .map((c) => c.trim().toUpperCase())
        .filter(Boolean);
      const status = normalizeStatus(rawStatus.trim());

      if (!companies.length) {
        return [`${time} - ${service} - ${status}`];
      }

      return companies.map((company) => `${time} - ${service} - ${company} - ${status}`);
    }

    function validarFixtures() {
      fixtures.forEach(({ description, input, expected }) => {
        const resultados = formatarLinhaParaTeste(input);
        if (!resultados.includes(expected)) {
          console.warn(`Fixture falhou (${description}):`, { input, expected, resultados });
          return;
        }
        console.info(`Fixture validada (${description}).`);
      });
    }

    function normalizeTime(value) {
      const match = value.trim().toLowerCase().match(/^(\d{1,2})[:h](\d{2})h?$/);
      if (!match) {
        return value.trim();
      }
      let [_, hh, mm] = match;
      const hour = String(Number(hh)).padStart(2, '0');
      return `${hour}:${mm}`;
    }

    function normalizeStatus(value) {
      let text = value.trim();
      const normalizedInput = normalizeMatchText(text);
      const rules = obterRegras();

      for (const rule of rules) {
        if (!rule || !rule.match) continue;
        const normalizedRule = normalizeMatchText(rule.match);
        if (normalizedRule && normalizedRule === normalizedInput) {
          return rule.value?.trim() || text;
        }
      }

      if (!/[.!?]$/.test(text)) {
        text += '.';
      }
      return text;
    }

    function stripAccents(text) {
      return text.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    }

    function normalizeMatchText(text) {
      return stripAccents(String(text)).toLowerCase().replace(/\s+/g, ' ').trim().replace(/[.!?]+$/, '');
    }

    function obterRegras() {
      return [...userRules, ...defaultRules];
    }

    function incDate(dateStr) {
      const parts = dateStr.split('/').map(Number);
      if (parts.length !== 3 || parts.some(Number.isNaN)) {
        return dateStr;
      }
      const [day, month, year] = parts;
      const date = new Date(year, month - 1, day);
      date.setDate(date.getDate() + 1);
      const nextDay = String(date.getDate()).padStart(2, '0');
      const nextMonth = String(date.getMonth() + 1).padStart(2, '0');
      const nextYear = date.getFullYear();
      return `${nextDay}/${nextMonth}/${nextYear}`;
    }

    async function copiar() {
      const text = document.getElementById('out').textContent;
      if (!text) {
        alert('Não há conteúdo para copiar.');
        return;
      }
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
        } else {
          throw new Error('Clipboard API indisponível');
        }
        alert('Lista copiada para a área de transferência!');
      } catch (err) {
        try {
          const temp = document.createElement('textarea');
          temp.value = text;
          temp.setAttribute('readonly', '');
          temp.style.position = 'fixed';
          temp.style.opacity = '0';
          document.body.appendChild(temp);
          temp.select();
          const successful = document.execCommand('copy');
          document.body.removeChild(temp);
          if (successful) {
            alert('Lista copiada para a área de transferência!');
            return;
          }
          throw new Error('Falha ao copiar');
        } catch (fallbackError) {
          alert('Não foi possível copiar automaticamente. Copie manualmente.');
        }
      }
    }

    function limpar() {
      document.getElementById('in').value = '';
      document.getElementById('out').textContent = '';
      document.getElementById('in').focus();
    }

    function carregarRegras() {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (!saved) {
        userRules = [];
        return;
      }
      try {
        const parsed = JSON.parse(saved);
        if (Array.isArray(parsed)) {
          userRules = parsed.filter((rule) => rule && typeof rule.match === 'string');
        }
      } catch (error) {
        userRules = [];
      }
    }

    function salvarRegra() {
      const match = document.getElementById('ruleMatch').value.trim();
      const value = document.getElementById('ruleValue').value.trim();
      if (!match || !value) {
        alert('Preencha o texto a detectar e a substituição.');
        return;
      }

      const newRule = { match, value };

      if (editingIndex !== null && editingIndex >= 0 && editingIndex < userRules.length) {
        userRules[editingIndex] = newRule;
        editingIndex = null;
      } else {
        userRules.push(newRule);
      }

      persistirRegras();
      limparCamposRegra();
      renderizarRegras();
    }

    function persistirRegras() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(userRules));
    }

    function limparCamposRegra() {
      document.getElementById('ruleMatch').value = '';
      document.getElementById('ruleValue').value = '';
      document.getElementById('ruleSaveButton').textContent = 'Salvar regra';
    }

    function renderizarRegras() {
      const container = document.getElementById('rulesList');
      container.innerHTML = '';

      const allRules = obterRegras();
      if (!allRules.length) {
        container.textContent = 'Nenhuma regra cadastrada.';
        return;
      }

      allRules.forEach((rule, index) => {
        const item = document.createElement('div');
        item.className = 'rule-item';

        const texts = document.createElement('div');
        texts.className = 'rule-texts';
        texts.innerHTML = `<strong>${rule.value}</strong><span>${rule.match}</span>`;

        const buttons = document.createElement('div');
        buttons.className = 'rule-buttons';

        const editBtn = document.createElement('button');
        editBtn.type = 'button';
        editBtn.className = 'secondary small-button';
        editBtn.textContent = 'Editar';
        editBtn.onclick = () => editarRegra(index);

        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'danger small-button';
        removeBtn.textContent = 'Remover';
        removeBtn.onclick = () => removerRegra(index);

        buttons.appendChild(editBtn);
        buttons.appendChild(removeBtn);

        item.appendChild(texts);
        item.appendChild(buttons);
        container.appendChild(item);
      });
    }

    function editarRegra(index) {
      const allRules = obterRegras();
      const rule = allRules[index];
      if (!rule) return;

      editingIndex = index >= userRules.length ? userRules.length : index;

      document.getElementById('ruleMatch').value = rule.match;
      document.getElementById('ruleValue').value = rule.value;
      document.getElementById('ruleSaveButton').textContent = 'Atualizar regra';
    }

    function removerRegra(index) {
      if (index >= userRules.length) {
        alert('Não é possível remover regras padrão. Edite-as para sobrescrever.');
        return;
      }
      userRules.splice(index, 1);
      persistirRegras();
      renderizarRegras();
      cancelarEdicao();
    }

    function cancelarEdicao() {
      editingIndex = null;
      limparCamposRegra();
    }

    function exportarXLSX() {
      if (!formattedRows.length) {
        alert('Não há conteúdo formatado para exportar.');
        return;
      }

      if (window.XLSX && !window.__xlsxFailed) {
        const data = [
          ['Data', 'Hora', 'Serviço', 'Empresa', 'Status'],
          ...formattedRows.map((row) => [row.date, row.time, row.service, row.company, row.status])
        ];

        const worksheet = XLSX.utils.aoa_to_sheet(data);
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, 'Registros');

        const timestamp = new Date().toISOString().replace(/[:T]/g, '-').split('.')[0];
        XLSX.writeFile(workbook, `noc-formatter-${timestamp}.xlsx`);
        return;
      }

      exportarCSV();
    }

    function exportarCSV() {
      const data = [
        ['Data', 'Hora', 'Serviço', 'Empresa', 'Status'],
        ...formattedRows.map((row) => [row.date, row.time, row.service, row.company, row.status])
      ];

      const csv = data.map((row) => row.map(escaparCSV).join(';')).join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      const timestamp = new Date().toISOString().replace(/[:T]/g, '-').split('.')[0];
      link.download = `noc-formatter-${timestamp}.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(link.href);

      const offlineMessage = window.__xlsxFailed || !window.XLSX ? '\nA biblioteca XLSX não pôde ser carregada; o arquivo foi exportado como CSV.' : '';
      alert(`Exportação concluída.${offlineMessage}`);
    }

    function escaparCSV(valor) {
      const text = String(valor ?? '');
      if (/[";\n]/.test(text)) {
        return `"${text.replace(/"/g, '""')}"`;
      }
      return text;
    }
  </script>
</body>
</html>
