(function (global) {
  'use strict';

  function columnName(index) {
    let name = '';
    let current = index;
    while (current >= 0) {
      name = String.fromCharCode((current % 26) + 65) + name;
      current = Math.floor(current / 26) - 1;
    }
    return name;
  }

  function xmlEscape(value) {
    return String(value ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }

  function aoa_to_sheet(data) {
    const sheet = { __rows: data.map((row) => row.slice()) };
    data.forEach((row, rIdx) => {
      row.forEach((value, cIdx) => {
        const addr = `${columnName(cIdx)}${rIdx + 1}`;
        const isNumber = typeof value === 'number' && Number.isFinite(value);
        sheet[addr] = { v: value, t: isNumber ? 'n' : 's' };
      });
    });
    if (data.length && data[0].length) {
      const endCol = columnName(data[0].length - 1);
      sheet['!ref'] = `A1:${endCol}${data.length}`;
    }
    return sheet;
  }

  function book_new() {
    return { SheetNames: [], Sheets: {} };
  }

  function book_append_sheet(workbook, worksheet, name) {
    workbook.SheetNames.push(name);
    workbook.Sheets[name] = worksheet;
  }

  function buildSheetXML(sheet) {
    const rows = sheet.__rows || [];
    const lines = ['<?xml version="1.0" encoding="UTF-8"?>',
      '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">',
      '<sheetData>'];

    rows.forEach((row, rIdx) => {
      if (!row) return;
      const rowIndex = rIdx + 1;
      const cells = [];
      row.forEach((value, cIdx) => {
        const address = `${columnName(cIdx)}${rowIndex}`;
        if (value === undefined || value === null) return;
        const isNumber = typeof value === 'number' && Number.isFinite(value);
        if (isNumber) {
          cells.push(`<c r="${address}"><v>${value}</v></c>`);
        } else {
          cells.push(`<c r="${address}" t="inlineStr"><is><t>${xmlEscape(value)}</t></is></c>`);
        }
      });
      lines.push(`<row r="${rowIndex}">${cells.join('')}</row>`);
    });

    lines.push('</sheetData>', '</worksheet>');
    return lines.join('');
  }

  function buildWorkbookXML(workbook) {
    const sheetsXml = workbook.SheetNames.map((name, idx) => {
      const sheetId = idx + 1;
      return `<sheet name="${xmlEscape(name)}" sheetId="${sheetId}" r:id="rId${sheetId}"/>`;
    }).join('');

    return ['<?xml version="1.0" encoding="UTF-8"?>',
      '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">',
      `<sheets>${sheetsXml}</sheets>`,
      '</workbook>'].join('');
  }

  function buildWorkbookRels(workbook) {
    const rels = workbook.SheetNames.map((_, idx) => {
      const sheetId = idx + 1;
      return `<Relationship Id="rId${sheetId}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet${sheetId}.xml"/>`;
    }).join('');

    return ['<?xml version="1.0" encoding="UTF-8"?>',
      '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">',
      rels,
      '</Relationships>'].join('');
  }

  function buildContentTypes(workbook) {
    const sheetOverrides = workbook.SheetNames.map((_, idx) => {
      const sheetId = idx + 1;
      return `<Override PartName="/xl/worksheets/sheet${sheetId}.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>`;
    }).join('');

    return ['<?xml version="1.0" encoding="UTF-8"?>',
      '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">',
      '<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>',
      '<Default Extension="xml" ContentType="application/xml"/>',
      '<Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>',
      sheetOverrides,
      '</Types>'].join('');
  }

  function buildRootRels() {
    return ['<?xml version="1.0" encoding="UTF-8"?>',
      '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">',
      '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>',
      '</Relationships>'].join('');
  }

  function utf8Encode(str) {
    return new TextEncoder().encode(str);
  }

  function crc32(buf) {
    const table = crc32.table || (crc32.table = (() => {
      const t = new Uint32Array(256);
      for (let i = 0; i < 256; i++) {
        let c = i;
        for (let k = 0; k < 8; k++) {
          c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
        }
        t[i] = c >>> 0;
      }
      return t;
    })());

    let crc = 0 ^ -1;
    for (let i = 0; i < buf.length; i++) {
      crc = (crc >>> 8) ^ table[(crc ^ buf[i]) & 0xff];
    }
    return (crc ^ -1) >>> 0;
  }

  function toUint8Array(value) {
    if (value instanceof Uint8Array) return value;
    return utf8Encode(value);
  }

  class ZipBuilder {
    constructor() {
      this.entries = [];
    }

    addFile(name, data) {
      const nameBytes = utf8Encode(name);
      const content = toUint8Array(data);
      const crc = crc32(content);
      this.entries.push({ nameBytes, content, crc });
    }

    build() {
      const chunks = [];
      let offset = 0;

      this.entries.forEach((entry) => {
        const localHeader = new Uint8Array(30 + entry.nameBytes.length);
        const view = new DataView(localHeader.buffer);
        view.setUint32(0, 0x04034b50, true);
        view.setUint16(4, 20, true);
        view.setUint16(6, 0, true);
        view.setUint16(8, 0, true);
        view.setUint16(10, 0, true);
        view.setUint16(12, 0, true);
        view.setUint32(14, entry.crc, true);
        view.setUint32(18, entry.content.length, true);
        view.setUint32(22, entry.content.length, true);
        view.setUint16(26, entry.nameBytes.length, true);
        view.setUint16(28, 0, true);

        chunks.push(localHeader, entry.nameBytes, entry.content);
        entry.offset = offset;
        offset += localHeader.length + entry.nameBytes.length + entry.content.length;
      });

      const centralChunks = [];
      let centralSize = 0;
      this.entries.forEach((entry) => {
        const centralHeader = new Uint8Array(46 + entry.nameBytes.length);
        const view = new DataView(centralHeader.buffer);
        view.setUint32(0, 0x02014b50, true);
        view.setUint16(4, 20, true);
        view.setUint16(6, 20, true);
        view.setUint16(8, 0, true);
        view.setUint16(10, 0, true);
        view.setUint16(12, 0, true);
        view.setUint16(14, 0, true);
        view.setUint16(16, 0, true);
        view.setUint32(18, entry.crc, true);
        view.setUint32(22, entry.content.length, true);
        view.setUint32(26, entry.content.length, true);
        view.setUint16(30, entry.nameBytes.length, true);
        view.setUint16(32, 0, true);
        view.setUint16(34, 0, true);
        view.setUint16(36, 0, true);
        view.setUint16(38, 0, true);
        view.setUint32(40, 0, true);
        view.setUint32(42, entry.offset, true);

        centralChunks.push(centralHeader, entry.nameBytes);
        centralSize += centralHeader.length + entry.nameBytes.length;
      });

      const endRecord = new Uint8Array(22);
      const endView = new DataView(endRecord.buffer);
      const localSize = offset;
      endView.setUint32(0, 0x06054b50, true);
      endView.setUint16(4, 0, true);
      endView.setUint16(6, 0, true);
      endView.setUint16(8, this.entries.length, true);
      endView.setUint16(10, this.entries.length, true);
      endView.setUint32(12, centralSize, true);
      endView.setUint32(16, localSize, true);
      endView.setUint16(20, 0, true);

      return new Blob([...chunks, ...centralChunks, endRecord], { type: 'application/zip' });
    }
  }

  function saveBlob(blob, filename) {
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);
  }

  function writeFile(workbook, filename) {
    const zip = new ZipBuilder();
    const sheetCount = workbook.SheetNames.length;

    for (let i = 0; i < sheetCount; i++) {
      const sheetName = workbook.SheetNames[i];
      const sheet = workbook.Sheets[sheetName];
      zip.addFile(`xl/worksheets/sheet${i + 1}.xml`, buildSheetXML(sheet));
    }

    zip.addFile('xl/workbook.xml', buildWorkbookXML(workbook));
    zip.addFile('xl/_rels/workbook.xml.rels', buildWorkbookRels(workbook));
    zip.addFile('[Content_Types].xml', buildContentTypes(workbook));
    zip.addFile('_rels/.rels', buildRootRels());

    saveBlob(zip.build(), filename);
  }

  const XLSX = {
    utils: { aoa_to_sheet, book_new, book_append_sheet },
    writeFile
  };

  global.XLSX = XLSX;
})(typeof window !== 'undefined' ? window : this);
